# 
# Functions that generate C code

# Generate c code given a template
# Tags take the form [[template::<tag>]]
gen_c_code <- function(parameters,         # System list
                       template,           # Template file
                       output=NULL,        # 
                       overwrite=FALSE,    #   
                       tags_list=NULL,     # tags list
                       tags_funs=NULL) {   # tags function
  
  if (is.null(tags_list)) {
    tags_list <- list('declarations', 'defines')
  }
  if (is.null(tags_funs)) {
    tags_funs <- list(gen_declarations, gen_defines)
  }
  if (is.null(output)) { 
    output <- paste0(dirname(str), '/../', sub(".template","", basename(str)))
  }
  
  # Read template
  txt <- readChar(template, file.info(template)$size)
  
  # Replace all tags
  for (n in seq.int(length(tags_list))) {
    message('Replacing ', mktag(tags_list[[n]]))
    txt <- replaceonetag(txt, 
                         tags_list[[n]], 
                         tags_funs[[n]](parameters))
  }
  
  if (file.exists(output) && !overwrite) {
    stop(paste0("Output file exists (",
                output,"). Override with overwrite=TRUE"))
  }
  
  writeChar(txt, output, eos=NULL)
  message('Wrote .c file to ', output)
  
  invisible(txt)
}

# Removes generated c files
clean_c_code <- function(template_dir) { 
  for (file in dir(template_dir, full.names=TRUE)) { 
    file_output <- gen_output(file)
    message('Removing ', file_output)
    if (file.exists(file_output)) file.remove(file_output)
  }
}

# Tag replacement
# ------------------------------------------

# Replace a tag name with correct elements
replaceonetag <- function(text, tagstring, what) { 
  sub(mktag(tagstring), mkrep(what), text, fixed=TRUE)
}

# Provide R timestamp
mkrep <- function(str) { 
  paste0('// Generated by R (', date(),')\n',str)
}

# Make pattern to replace from a tag string
mktag <- function(str) { 
  paste0("[[template::",str,"]]")
} 

# Generators
# ------------------------------------------

# Generate #define macros for symbolic constants
gen_defines <- function(parms, ...) { 
  
  
  nspecies <- vecmat_switch(parms[[1]], length(parms[[1]]), ncol(parms[[1]]))
  
  nparms  <- length(vectorize_parameters(parms, nspecies))
  
  txt <- paste0("#define Nsp ", nspecies[[1]], "\n",
                "#define Np ",  nparms,       "\n")
  
  return(txt)
}

# Generate all values declaration ( double XX[Nsp][Nsp] ) given a list of
# parameters. See also the ./R/system_create.R file for more parameters
# handling related to c code.
gen_declarations <- function(parms) { 
  
  # Read parms and generate the non-trophic components if necessary
  nspecies <- vecmat_switch(parms[[1]], length(parms[[1]]), ncol(parms[[1]]))
  
  parms <- prepare_parms(parms, nspecies)
  
  declarations <- mapply(gen_onedeclaration, 
                         names(parms),
                         parms)
  
  paste(declarations, collapse="\n")
}
gen_onedeclaration <- function(parm.name, parm.value) {
  paste0('double ', parm.name, 
         gen_size_qualifier(parm.value), ";")
}

# Utils 
# ------------------------------------------
# Generate a size qualifier for a declaration (the [y] in double x[y])
gen_size_qualifier <- function(elem) { 
  dimswitch(elem, 
            paste0("[", length(elem),"]"),
            paste0("[", nrow(elem),  "][", ncol(elem),  "]"),
            paste0("[", dim(elem)[1],"][", dim(elem)[2],"][",dim(elem)[3],"]"))
}

# Checks if an element is a matrix or a vector or else
vecmat_switch <- function(thing, isvec, ismat, elsefun=stop) { 
  # Get size of element
  if (is.vector(thing)) { 
    return(isvec)
  } else if (is.matrix(thing)) { 
    return(ismat)
  } else { 
    stop('Not a matrix or a vector, check input')
  }
}
