#include <R.h>
#include "exports.h"
#include <math.h> // for fmax

// Print debug messages ?
static int dbg=0;
static double zerotol=1e-8; 
static double eq_zerotol=1e-16; 

/*
 * Note: C STORES ARRAYS IN ROW-MAJOR ORDER !!!
*/

/* The template processing in R will produce two #define macros here for : 
 *   - Nsp : the number of species (equal to *neq in the solver function)
 *   - Np  : the number of parameters 
 */

// [[template::defines]]

/* We pass all our parameters as a big array of doubles. For convenience we 
 * define here a union/struct that allows referring to them as p.<name> so 
 * the code is much more readable. 
 * 
 * Same thing here, the tag will be replaced by the actual values of the 
 * parameters.
 */
union p { 
  struct {  
    // [[template::declarations]]
  };
  double value[Np];
} p; // instance (name to be referred to)

/* We want to be able to determine if the system is at equlibrium to perform
 * an action. To do this we need to have a globally available copy of the 
 * derivatives. 
 * This line defines this array.
 */
double ydot_global[Nsp];

/* We want to stop when some number of equilibirum has been reached: we store
 * the maximum number of equilibria to reach in maxeq. Note that this is 
 * stored a double, but deSolve provides correct handling for that.
 */
double remaining_eq=2;

/* Same thing here, we need to have the parameters globally available. This 
 * function (provided by deSolve) takes care of this.
 */
void initmod(void (* odeparms)(int *, double *)) {
  int N=Np;
  odeparms(&N, p.value); 
}

/* This function solves for a root (returns 0 if root is reached) and follows
 * the guidelines provided by deSolve. It allows us to monitor the behavior
 * of the model and decide on what to do.
 */
void controlf(int *neq, 
              double *t, 
              double *y, 
              int *ng, 
              double *gout,
              double *out, 
              int *ip) { 
  
  // We store the maximum derivative in gout[0] and the number of roots. Do not
  // set to 0 (otherwise there will be a false equilibirum detected on step 1)
  // 
  // We do our own root detection instead of passing the job to deSolve 
  // because we need to count the number of equilibria reached.
  // Note that deSolve triggers stuff when roots are zero !!!
  double eq_unreached = -1; 
  
  // We decide whether to stop or not the simulation depending on the number 
  // of equilibria we have reached so far.
  int got_eq = 0;
  
  got_eq = eq_reached(neq, ydot_global, &eq_zerotol);
  
  if (got_eq) { // eq reached
    eq_unreached = 0.0;
    // decrease the counter of the max number of eq to reach (/!\ double !) 
    // we stop the run when this counter gets to zero
    remaining_eq = fmax(remaining_eq - 1.0, 0.0);  
  }
  
  // Put the return values where they belong
//   Rprintf("%f | %f | \n", gout[0], gout[1]);
  gout[0] = eq_unreached;
  gout[1] = remaining_eq;
}




/* We define here an event that will happen at a time specified in R */
void spkill(int *n, double *t, double *y) { 
  // Modifies the system's state in place !
  y[3] = y[3]/2; // OMG dead stuff
}




/* This is the core function of the model that returns the 
 * partial derivatives */
void derivs(int *neq,     // neq is the number of equations
            double *t,    // value of the independent variable (time)
            double *y,    // current state
            double *ydot, // will contain the derivatives
            double *yout, // vector with [nout values of other output variables] 
                          // ++ [rpar values]
            int *ip)      // [number of output vals, 
                          //  length of yout,
                          //  length of *ip]
{ 
  double funcresp=0; // functional response
  
  // Ensures correct memory allocation (we do not use nout so no need for it !)
  //   if (ip[0] < 1) error("nout should be at least 1");
  // Compute logistic growth for each species
  for (int i=0; i<*neq; i++) { 
    ydot[i] = p.r[i] * y[i] * (1 - y[i] / p.K[i]);
  }
  
  // Compute effect of trophic interactions
  for (int i=0; i<*neq; i++) {
    for (int j=0; j<*neq; j++) {
      
      if (dbg) { 
        if (i == 1 && j == 0) { 
          Rprintf("%i %i: %f |", i+1, j+1, 
                  frtype2(&y[j], &p.atk[i][j], &p.h[j]));
        }
      }
      
      // Species i eats j
      funcresp = frtype2(&y[j], &p.atk[i][j], &p.h[j]);
      ydot[i] += y[i] * p.w[i][j] * funcresp;
      
      // Species i gets eaten by j
      funcresp = frtype2(&y[i], &p.atk[j][i], &p.h[i]);
      ydot[i] += - y[j] * p.w[j][i] * funcresp / p.e[j][i];
      
    }
  }
  
  // Mortality
  for (int i=0; i<*neq; i++) { 
    ydot[i] += - p.x[i] * y[i];
  }
  
  if (dbg) { 
    Rprintf("\n");
  }
  
  // Export ydot and compute some other stuff
  for (int i=0; i<*neq; i++) { 
    ydot_global[i] = ydot[i];
  }
  
  // Set very small species abundances to zero
  for (int i=0; i<*neq; i++) { 
    
    if (y[i] < zerotol) { 
      // We set also ydot[i] to zero as numerical errors (?) make the population 
      // recover 
      ydot[i] = - y[i];
    }
    
  }
  
  // NB: there is no need to return anything: all the stuff is modified in place
  // and [ydot]++[yout] is returned
}
