#include <R.h>
#include <exports.h>
#include <math.h> // for fmax, round
#include <float.h> // for float limits

#define min_step_btw_root 5
#define remaining_eq_value  2.0 // max number of eqs to consider

/* The template processing in R will produce two #define macros here for : 
 *   - Nsp : the number of species (equal to *neq in the solver function)
 *   - Np  : the number of parameters 
 */
// [[template::defines]]

// Print debug messages ?
// static double eq_zerotol = 1e-30; // max derivs value to consider eq
static double zerotol = 1e-5;    // min abundance of a species
int steps_since_root;  // min number of evaluations to consider 
                       // btw two equilibrium

// Note: C STORES ARRAYS IN ROW-MAJOR ORDER !!!

/* We pass all our parameters as a big array of doubles. For convenience we 
 * define here a union/struct that allows referring to them as p.<name> so 
 * the code is much more readable. 
 * 
 * Same thing here, the tag will be replaced by the actual values of the 
 * parameters.
 */
union parms { 
  struct {  
    // [[template::declarations]]
  };
  double value[Np];
} p; // instance (name to be referred to)

/* We want to be able to determine if the system is at equlibrium to perform
 * an action. To do this we need to have a globally available copy of the 
 * derivatives. 
 * This line defines this array.
 */
double ydot_global[Nsp];

/* We want to stop when some number of equilibirum has been reached: we store
 * the maximum number of equilibria to reach in maxeq. Note that this is 
 * stored a double, but deSolve provides correct handling for floating point
 * errors.
 */
double remaining_eq;

/* We store an array containing the extant species as a global variable: this
 * array is looped over to determine which species are interacting with each
 * other */
int extant_species[Nsp];
int extant_n;

/* Same thing here, we need to have the parameters globally available. This 
 * function (provided by deSolve) takes care of this.
 * 
 * We also reset the global values.
 */
void initmod(void (* odeparms)(int *, double *)) {
  // Reset global values
  remaining_eq     = remaining_eq_value;
  steps_since_root = min_step_btw_root;
  
  // initialize species statuses
  extant_n = Nsp;
  for (int i=0; i<Nsp; i++) {
    extant_species[i] = i;
  }
  
  // non-zero the derivatives on start so there is no equilibrium detected
  // on step 1
  memset(ydot_global, 1, sizeof(ydot_global)); 
  
  // Copy params values into correct array
  int N=Np;
  odeparms(&N, p.value); 
}

/* We define here an event that will happen at a time specified in R */
void remove_species(int *n, double *t, double *y) { 
  // Modifies the system's state in place !
  
  // Note the -1 to adjust for R indexing and the lrint to cast 
  // p.removed_species values to an integer.
  // We use a long integer because there is no double -> int rounding function,
  // but it seems to work the same as far as indexing is concerned.
  
  for (int i=0; i < Nsp; i++) { 
    // We encode the removal status with 0/1 as doubles
    if (p.removed_species[i] > .5) { 
      // Rprintf("Removing %i (total:%i)\n", which_species+1, N_remove);
      y[i] = 0.0; // OMG dead stuff
    }
  }
  
}




/* This is the core function of the model that returns the 
 * partial derivatives */
void derivs(int *neq,     // neq is the number of equations
            double *t,    // value of the independent variable (time)
            double *y,    // current state
            double *ydot, // will contain the derivatives
            double *yout, // vector with [nout values of other output variables] 
                          // ++ [rpar values]
            int *ip)      // [number of output vals, 
                          //  length of yout,
                          //  length of *ip]
{ 
  double sumprey = 0;
  double F[Nsp][Nsp]; 
  
  // Default values for ydot is 0 
  memset(ydot, 0, sizeof(*ydot) * Nsp);
  
  // Get species still in the system and initialize
  int extant_n=0;
  for (int i=0; i<Nsp; i++) { 
    if ( y[i] > zerotol ) { 
      extant_species[extant_n] = i;
      extant_n++;
    }
  }
  
  // Compute non-trophic interactions coefficients here
  // TODO: this is silly, it should be in a subfunction but we cannot pass 
  // arrays to function (answer: use the gsl).
  double r_nt[Nsp];
  double K_nt[Nsp];
  for (int i=0; i<Nsp; i++) { 
    r_nt[i] = p.r[i];
    K_nt[i] = p.K[i];
  }
  
  for (int i=0; i<Nsp; i++) { 
    for (int j=0; j<Nsp; j++) { 
      if (p.dr[j][i] >= 0.1) 
        r_nt[i] += y[j] * nti_ratfun(&y[i], &p.yt[i], &p.r[i], &p.dr[j][i]); 
      if (p.dK[j][i] >= 0.1) // yes to only consider stuff that make sense
        K_nt[i] += y[j] * nti_ratfun(&y[i], &p.yt[i], &p.K[i], &p.dK[j][i]); 
    }
  }
  
//   Rprintf("K3:%e\n", K_nt[3]);
  
  // Compute functional responses between species
  for (int sp=0; sp<extant_n; sp++) { 
    
    // Focus species is i so it is easier to read
    int i = extant_species[sp];
    
    // Compute the total biomass of preys available to species i * atk 
    // coefficient, needed for the functional response.
    // Ideally, this would be in frhill but there is no simple way to pass 
    // a 2D matrix.
    sumprey = 0;
    for (int sp2=0; sp2<extant_n; sp2++) {
      int j = extant_species[sp2];
      
      sumprey += p.atk[i][j] * pow(y[j], 1.0 + p.q[0]);
    }
    
    // Fill functional responses array. Note that functional response also 
    // includes the atk and w coeffs, etc.
    // We alter parameters due to non-trophic     interactions here
    for (int sp2=0; sp2<extant_n; sp2++) { 
      int j = extant_species[sp2];
      F[i][j] = p.w[i][j] * p.atk[i][j] * pow(y[j], 1.0 + p.q[0]) / 
                  ( 1 + ( p.w[i][j] * p.h[i] * sumprey ) );
      
    }
  }
  
  /* Main pop dynamics loop */
  for (int sp=0; sp<extant_n; sp++) { 
    // Focus species is i so it follows the formulae 
    int i = extant_species[sp];
      
      
      /* Compute logistic growth
       * -------------------- */
      
      // Compute the true K[i] value as a result of non-trophic interactions
      ydot[i] = r_nt[i] * y[i] * ( 1 - y[i] / K_nt[i] );
      
      
      /* Trophic interactions
       * -------------------- */
      
      for (int sp2=0; sp2<extant_n; sp2++) {
        int j = extant_species[sp2];
          
        // Species i eats j
        ydot[i] += y[i] * F[i][j];
          
        // Species i gets eaten by j
        ydot[i] += - y[j] * F[j][i] / p.e[j][i];
          
      }
      
      
      /* Mortality 
       * --------- */
      ydot[i] += - p.x[i] * y[i];
      
  } // -- end of loop on extant species 
  
  // NB: there is no need to return anything: all the stuff is modified in place
}
